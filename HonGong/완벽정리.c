//구분없이 일단 정리 되는것들 적고 그걸 해당 소스파일에 재조합하기 위한 소스파일임

#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<string.h>



/*=======================(문자열)strchr 함수 정리============================*/

//void main(void)
//{
//	char str[256];
//	char *ptr;
//	int count = 0;
//
//	printf("아무문자 입력하세요(공백없이 최대 255문자)");
//	scanf("%s", str);
//	for (ptr = str;;)
//	{
//		ptr = strchr(ptr, 'a');//ptr문자열중에서 a가 들어가있는 위치의 주소를 가지고있는게 strchr 
//		if (ptr == NULL) //ptr에서 a가 더이상 없으면 NULL 리턴한다.
//		{
//			break;
//		}
//		count++;
//		ptr++;//증가 시키는 이유는 이미 앞주소의 글자를 확인했기 때문임 만약 증가를 안시키게되면 앞의 글자를 다시 검사하는데 앞글자가 조건식의 문자라면 계속 count셀것이기 때문이다.
//	}
//	printf("입력한 문자열에 a는 %d 개 있습니다.\n", count);
//}

/*==============================이중포인터 실습 정리 ===============================*/
//void main()
//{
//	int i = 1234; //주소를 100이라 가정
//	int *pi = &i; //주소를 200이라 가정
//	int **ppi = &pi; // 주소를 300이라 가정
//
//	printf("%d\n", **ppi);
//	// *로 찍은 요소가 주소면 해당 주소로 이동해서 찍힌다 생각하면 쉬움 
//	// *(*ppi) => ppi변수 안의 값 = pi주소 ==> &pi를 찍고있는거다. 그런데 pi도 변수값이 변수i의 주소를 찍고 있다.
//	// 그래서 해당 주소로 이동해서 찍힌다. *pi => &i ==> 그런데 우리가 찍을건 최종적으로 요소값을 찍으려 하고있다. 그렇기때문에 1234가 찍힌다.
//
//	printf("%p\n", *&pi); 
//	//전체적으로 이중으로 의미가 부여되어있을땐 변수 앞의 연산자부터 처리한다 생각하면 된다.
//	//*(&pi) ==> pi의 주소는 자기자신이다.(200) => 결국 주소가 200인 메모리의 요소값을 출력하라는 의미다 == 자기자신의 값이 나온다 그런데 자신의값이 i의 주소다 그래서 i의 주소가 찍힌다.
//
//	printf("%p\n", *&ppi);
//	printf("%p\n", &i);
//	printf("%d\n", *pi);
//	//맨위의 경우와 동일하다. pi의 요소값은 i의 주소다 그래서 i를 가리키고있다. 가리키고있는 주소의 요소값을 찍으라는 의미이기에 1234가 나온다.
//}

